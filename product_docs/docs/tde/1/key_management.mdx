---
title: "Key Management"
---

The key for transparent data encryption (the data key) is normally generated by initdb and stored in a file pg_encryption/key.bin under the data directory. (This file actually contains several keys that are used for different purposes at run time; see below for details. But for the purpose of this section, it contains a single sequence of random bytes.)

If nothing else were done, this file would contain the key in plaintext. This would be insecure because someone who got ahold of the encrypted data directory would have access to the plaintext key, thus defeating the purpose of encryption. Therefore, this setup is only suitable for testing purposes.

To secure the data key properly, it should be “wrapped” by encrypting it with another key. There are broadly two possibilites to arrange this:

- The data key is protected by a passphrase. This means that a wrapping key is derived from the passphrase and it used to encrypt the data key.

- The wrapping key is stored elsewhere, for example in a key management system. (This second key is also called the key-wrapping key or master key.)

PostgreSQL leaves the configuration of this up to the user, which allows tailoring the setup to local requirements and integrating with existing key management software or similar. To configure the data key protection, a pair of external commands needs to be specified that take care of the wrapping (encrypting) and unwrapping (decryption) respectively.

For example, suppose you want to protect the data key by a passphrase. This can be done using the openssl command-line utility. The following is an example invocation that sets this up:

```shell
initdb -D datadir -y --key-wrap-command='openssl enc -e -aes128-wrap -pbkdf2 -out %p' --key-unwrap-command='openssl enc -d -aes128-wrap -pbkdf2 -in %p'
```

This will wrap the randomly generated data key (done internally by initdb) by encrypting it using the AES-128-WRAP (AESKW) algorithm. The encryption uses a key derived from a passphrase using the PBKDF2 key derivation function and a randomly generated salt. The passphrase will be prompted for on the terminal. (See the openssl-enc manual page for details of these options. Available options vary across versions.) The placeholder %p is replaced by the name of the file where the wrapped key should be stored. The unwrap command performs the opposite operation. initdb does not itself need the unwrap operation but it will store it in the postgresql.conf of the initialized cluster, which will use it when it starts up.

!!! Note
    Key unwrap commands that prompt for passwords on the terminal will not work when the server is started by pg_ctl or through service managers such as systemd, because the server will be detached from the terminal in those environments. If an interactive password prompt on server start is desired, a more elaborate configuration will be required (for example, using systemd-ask-password).

The key wrap command will receive the plaintext key on standard input and needs to put the wrapped key at the file system location specified by the %p placeholder. The key unwrap command needs to read the wrapped key from the file system location specified by the %p placeholder and write the unwrapped key to the standard output.

Some utility programs operate directly on the data directory (or copies thereof, such as backups), such as pg_rewind and pg_upgrade. These programs will, depending on the circumstances, also need to be told about the key unwrap command. They each have command-line options for this purpose.

To simplify operations, the key wrap and unwrap commands can also be set in environment variables. These are accepted by all affected applications if no corresponding command-line options have been given. Example:

```shell
PGDATAKEYWRAPCMD='openssl enc -e -aes128-wrap -pbkdf2 -out %p'
PGDATAKEYUNWRAPCMD='openssl enc -d -aes128-wrap -pbkdf2 -in %p'
export PGDATAKEYWRAPCMD PGDATAKEYUNWRAPCMD
```

External key management systems can be used by the same mechanisms. Here is an example using the AWS Key Management Service (leaving out details such as how to set up credentials):

```shell
aws kms create-key
aws kms create-alias --alias-name alias/pg-tde-master-1 --target-key-id "..."
```

```shell
PGDATAKEYWRAPCMD='aws kms encrypt --key-id alias/pg-tde-master-1 --plaintext fileb:///dev/stdin --output text --query CiphertextBlob | base64 -d > %p'
PGDATAKEYUNWRAPCMD='aws kms decrypt --key-id alias/pg-tde-master-1 --ciphertext-blob fileb://%p --output text --query Plaintext | base64 -d'
```

!!! Note
    Shell commands with pipes, as in the above example, are problematic because the exit status of the pipe is that of the last command, and so a failure of the first (more interesting) command would not be reported properly. PostgreSQL will handle this somewhat by recognizing whether the wrap or unwrap command wrote nothing. It is better to make this more robust, however, for example by using the pipefail option available in some shells or the mispipe command available on some operating systems. More complicated commands should probably be put into an external shell script or other program instead of being defined inline.

If no key wrapping is wanted (for testing), then the wrap and unwrap commands must be set to an empty string. This specifies to use the key from the file without further processing. This is distinct from not setting a wrap or unwrap command at all. Having no wrap or unwrap command set when transparent data encryption is used will result in a fatal error when running an affected utility program.