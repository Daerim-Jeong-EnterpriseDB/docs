---
title: Securing the data encryption key
---


The key for transparent data encryption (the data key) is normally generated by initdb and stored in a file pg_encryption/key.bin under the data directory. (This file actually contains several keys that are used for different purposes at run time; see below for details. But for the purpose of this section, it contains a single sequence of random bytes.)

If nothing else were done, this file would contain the key in plaintext. This would be insecure because someone who got ahold of the encrypted data directory would have access to the plaintext key, thus defeating the purpose of encryption. Therefore, this setup is only suitable for testing purposes.

To secure the data key properly, it should be “wrapped” by encrypting it with another key. There are broadly two possibilities to arrange this:

- The data key is protected by a passphrase. This means that a wrapping key is derived from the passphrase and it used to encrypt the data key.

- The wrapping key is stored elsewhere, for example in a key management system (key store). This second key is also called the key-wrapping key or master key.

If no key wrapping is wanted (for testing), then the wrap and unwrap commands must be set to an empty string. This specifies to use the key from the file without further processing. This is distinct from not setting a wrap or unwrap command at all. Having no wrap or unwrap command set when transparent data encryption is used will result in a fatal error when running an affected utility program.

Postgres leaves the configuration of this up to the user, which allows tailoring the setup to local requirements and integrating with existing key management software or similar. To configure the data key protection, a pair of external commands needs to be specified that take care of the wrapping (encrypting) and unwrapping (decryption) respectively.

## Using a passphrase 

You can protect the data key by a passphrase using the openssl command line utility. The following is an example invocation that sets this up:

```shell
initdb -D datadir -y --key-wrap-command='openssl enc -e -aes128-wrap -pbkdf2 -out "%p"' --key-unwrap-command='openssl enc -d -aes128-wrap -pbkdf2 -in "%p"'
```

This will wrap the randomly generated data key (done internally by initdb) by encrypting it using the AES-128-WRAP (AESKW) algorithm. The encryption uses a key derived from a passphrase using the PBKDF2 key derivation function and a randomly generated salt. The passphrase will be prompted for on the terminal. (See the openssl-enc manual page for details of these options. Available options vary across versions.) The placeholder `%p` is replaced by the name of the file where the wrapped key should be stored. The unwrap command performs the opposite operation. initdb does not itself need the unwrap operation but it will store it in the postgresql.conf of the initialized cluster, which will use it when it starts up.

!!! Note
    Key unwrap commands that prompt for passwords on the terminal will not work when the server is started by pg_ctl or through service managers such as systemd, because the server will be detached from the terminal in those environments. If an interactive password prompt on server start is desired, a more elaborate configuration will be required (for example, using systemd-ask-password).

The key wrap command will receive the plaintext key on standard input and needs to put the wrapped key at the file system location specified by the `%p` placeholder. The key unwrap command needs to read the wrapped key from the file system location specified by the `%p` placeholder and write the unwrapped key to the standard output.

Some utility programs operate directly on the data directory (or copies thereof, such as backups), such as pg_rewind and pg_upgrade. These programs will, depending on the circumstances, also need to be told about the key unwrap command. They each have command-line options for this purpose.

To simplify operations, the key wrap and unwrap commands can also be set in environment variables. These are accepted by all affected applications if no corresponding command line options have been given. For example:

```shell
PGDATAKEYWRAPCMD='openssl enc -e -aes128-wrap -pbkdf2 -out "%p"'
PGDATAKEYUNWRAPCMD='openssl enc -d -aes128-wrap -pbkdf2 -in "%p"'
export PGDATAKEYWRAPCMD PGDATAKEYUNWRAPCMD
```

## Using a key store 
You can use the key store in an external key management system to manage the data encryption key. The tested and supported key stores are:

- Amazon AWS Key Management Service (KMS)
- Google Cloud - Cloud Kay Management Service
- Microsoft Azure Key Vault
- Thales CipherTrust Manager



### AWS Key Management Service example

To create a key with AWS Key Management Service: 

```shell
aws kms create-key
aws kms create-alias --alias-name alias/pg-tde-master-1 --target-key-id "..."
```

To specify that we should use the `aws kms` command with the `alias/pg-tde-master-1` key we created, to wrap and unwrap the data encryption key:

```shell
PGDATAKEYWRAPCMD='aws kms encrypt --key-id alias/pg-tde-master-1 --plaintext fileb:///dev/stdin --output text --query CiphertextBlob | base64 -d > "%p"'
PGDATAKEYUNWRAPCMD='aws kms decrypt --key-id alias/pg-tde-master-1 --ciphertext-blob fileb://"%p" --output text --query Plaintext | base64 -d'
```
!!! Note
    Shell commands with pipes, as in the example above, are problematic because the exit status of the pipe is that of the last command, and so a failure of the first (more interesting) command would not be reported properly. Postgres will handle this somewhat by recognizing whether the wrap or unwrap command wrote nothing. It is better to make this more robust, however, for example by using the `pipefail` option available in some shells or the `mispipe` command available on some operating systems. More complicated commands should probably be put into an external shell script or other program instead of being defined inline.

Alternatively, you can use the [crypt utility] https://github.com/VirtusLab/crypt to wrap and unwrap the data encryption key:

```shell
PGDATAKEYWRAPCMD='crypt encrypt aws --out %p --region us-east-1 --kms alias/pg-tde-master-1'
PGDATAKEYUNWRAPCMD='crypt decrypt aws --in %p --region us-east-1'
```
### Azure Key Vault example

To create a key with Azure Key Vault: 

```shell
az keyvault key create --vault-name pg-tde --name pg-tde-master-1
```

To specify that we should use the `az keyvault` command with the `pg-tde-master-1` key we created, to wrap and unwrap the data encryption key:

```shell
PGDATAKEYWRAPCMD='crypt encrypt azure --vaultURL https://pg-tde.vault.azure.net --name pg-tde-master-1 --version fa2bf368449e432085318c5bf666754c --out %p'
PGDATAKEYUNWRAPCMD='crypt decrypt azure --vaultURL https://pg-tde.vault.azure.net --name pg-tde-master-1 --version fa2bf368449e432085318c5bf666754c --in %p'
```

This uses https://github.com/VirtusLab/crypt. The Azure CLI cannot be used directly for this, because it lacks some functionality.

### Google Cloud KMS example

To create a key with Google Cloud KMS: 

```shell
gcloud kms keys create pg-tde-master-1 --location=global --keyring=pg-tde --purpose=encryption
```

To specify that we should use the `az keyvault` command with the `pg-tde-master-1` key we created, to wrap and unwrap the data encryption key:

```shell
PGDATAKEYWRAPCMD='gcloud kms encrypt --plaintext-file=- --ciphertext-file=%p --location=global --keyring=pg-tde --key=pg-tde-master-1'
PGDATAKEYUNWRAPCMD='gcloud kms decrypt --plaintext-file=- --ciphertext-file=%p --location=global --keyring=pg-tde --key=pg-tde-master-1'
```

Alternatively, you can use the [crypt utility] https://github.com/VirtusLab/crypt to wrap and unwrap the data encryption key:

```shell
PGDATAKEYWRAPCMD='crypt encrypt gcp --out=%p --location=global --keyring=pg-tde --key=pg-tde-master-1 --project your-project-123456'
PGDATAKEYUNWRAPCMD='crypt decrypt gcp --in=%p --location=global --keyring=pg-tde --key=pg-tde-master-1 --project your-project-123456'
```


