---
title: Maintenance commands through proxies
---

PGD clusters nodes are able to present a direct connection for psql and pgd cli clients which can be used for issuing maintenance commands to the Postgres server on those nodes. But the environment in which the PGD cluster is deployed may mean that as a user you cannot use those direct connections. 

For example, in BigAnimal, PGD clusters are locked down such that the only access to the database is through an instance of PGD Proxy. This reduces the footprint of the cluster and makes it more secure but it does require a different way of sending maintenance requests to the cluster’s nodes.

The technique outlined here is generally useful for despatching commands to specific nodes without being directly connected to that node’s server.

## Maintenance commands

When we refer to maintenance commands, we are referring to:

* `VACUUM` 
* Non-replicated DDL commands (which you may want to manually replicate)


## A note on node names

We will be addressing the servers in the cluster by their PGD cluster node names. To get a list of node names in your cluster, use:

```SQL
select node_name from bdr.node;
```

!!! Tip
More details about [`bdr.node`](/pgd/latest/reference/catalogs-visible#bdrnode) table are available in the reference section.
!!!

This will list just the node names. If you need to know which group they are a member of, use:

```
select node_name, node_group_name from bdr.node_summary;
```

!!! Tip
More details about [`bdr.node_summary`](/pgd/latest/reference/catalogs-visible#bdrnode_summary) table are available in the reference section.
!!!

## Using `bdr.run_on_nodes()`
PGD does have the ability to run specific commands on specific nodes using the `bdr.run_on_nodes()` function. This takes two parameters, an array of node names and the command you would like to run on those nodes. For example:

```SQL
SELECT bdr.run_on_nodes(ARRAY['p-wqnqz5x7ta-a-1','p-wqnqz5x7ta-a-3'],'vacuum full foo');
__OUTPUT__

                                                            	run_on_nodes
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 [{"dsn": "host=p-wqnqz5x7ta-a-1-node.pg.biganimal.io sslmode=verify-full port=5432 dbname=bdrdb", "node_id": "807899305", "response": {"command_status": "VACUUM"}, "node_name": "p-wqnqz5x7ta-a-1", "query_send_time": "2024-01-16 16:24:35.418323+00"}, {"dsn": "host=p-wqnqz5x7ta-a-3-node.pg.biganimal.io sslmode=verify-full port=5432 dbname=bdrdb", "node_id": "199017004", "response": {"command_status": "VACUUM"}, "node_name": "p-wqnqz5x7ta-a-3", "query_send_time": "2024-01-16 16:24:35.4542+00"}]
```

Would run the vacuum full foo command on the *-1 and *-3 nodes and report the results as JSONB, Note that the node names are passed in an array. The results include the name of the node and the response ( or error message)  resulting from running the command, along with various other fields which may or may not be relevant. It’s also formatted as a single row. To make it more readable, we can apply some formatting.

## Formatting `bdr.run_on_nodes()` output

Using Postgres’s JSON expressions, it is possible to reduce the output to just the columns we are interested in. The following command is functionally equivalent to the previous example but lists only the node and response as its results:

```SQL
select q->>'node_name' as node, q->>'response' as response FROM jsonb_array_elements(bdr.run_on_nodes(ARRAY['p-wqnqz5x7ta-a-1','p-wqnqz5x7ta-a-3'], 'VACUUM FULL foo')) q;
__OUTPUT__
         node     |       	response
------------------+------------------------------
 p-wqnqz5x7ta-a-1 | {"command_status": "VACUUM"}
 p-wqnqz5x7ta-a-3 | {"command_status": "VACUUM"}
```

If an error occurs, the command_status field will be set to error and an additional error_message value will be included in the response. For example:

```SQL
select q->>'node_name' as node, q->>'response' as response FROM jsonb_array_elements(bdr.run_on_nodes(ARRAY['p-wqnqz5x7ta-a-1','p-wqnqz5x7ta-a-3'], 'VACUUM FULL fool')) q;
__OUTPUT__
   	node   	      |                                      	response
------------------+--------------------------------------------------------------------------------------------
 p-wqnqz5x7ta-a-1 | {"error_message": "ERROR:  relation \"fool\" does not exist\n", "command_status": "ERROR"}
 p-wqnqz5x7ta-a-3 | {"error_message": "ERROR:  relation \"fool\" does not exist\n", "command_status": "ERROR"}
(2 rows)
```

## Defining a function for maintenance

If you find yourself regularly issuing maintenance commands to one node at a time, you do have the option to define a function to simplify things:

```SQL
create or replace function runmaint(nodename varchar, command varchar) returns TABLE(node text,response jsonb) as $$
begin
return query
select (q->>'node_name')::text, (q->'response') from jsonb_array_elements(bdr.run_on_nodes(ARRAY [nodename], command)) as q;
end;
$$ language 'plpgsql';
```

This function takes a node name and a command and runs the command on that node, returning the results like so:

```SQL
select runmaint('p-wqnqz5x7ta-a-1','VACUUM FULL foo');
__OUTPUT__
                   	runmaint
-------------------------------------------------------
 (p-wqnqz5x7ta-a-1,"{""command_status"": ""VACUUM""}")
```

You can break up the response by using select * from :

```SQL
select * from runmaint('p-wqnqz5x7ta-a-1','VACUUM FULL foo');
__OUTPUT__
   	node          |       	response
------------------+------------------------------
 p-wqnqz5x7ta-a-1 | {"command_status": "VACUUM"}
(1 row)
```

